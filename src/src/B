public int move(PacmanGame game) {
		int code = 0;
        		int[][] board = game.getGame(code);
        		Ex3P.Index2D pacmanPos = parsePos(game.getPos(code));
        		GhostCL[] ghosts = game.getGhosts(code);
        		int black = Game.getIntColor(Color.BLACK, code);

        		// 1. עדכון המפה
        		if (_map == null) {
        			_map = new Ex3P.Map(board);
        		} else {
        			_map.init(board);
        		}

        		// 2. חישוב מפת מרחקים
        		Ex3P.Map2D distFromMe = _map.allDistance(pacmanPos, black);

        		// 3. מציאת איומים והזדמנויות
        		GhostCL closestDangerousGhost = null;
        		int minDistToDanger = Integer.MAX_VALUE;

        		for (GhostCL g : ghosts) {
        			Ex3P.Index2D gPos = parsePos(g.getPos(0));
        			// נשתמש במרחק אווירי לבדיקת סכנה מיידית ליתר ביטחון
        			int d = (int) pacmanPos.distance2D(gPos);

        			if (g.remainTimeAsEatable(0) <= 0) { // רוח מסוכנת
        				if (d < minDistToDanger) {
        					minDistToDanger = d;
        					closestDangerousGhost = g;
        				}
        			}
        		}

        		// --- היררכיית החלטות משופרת ---

        		// א. בריחה מרוחות (עדיפות עליונה)
        		if (closestDangerousGhost != null && minDistToDanger < 4) {
        			return getSmartFleeMove(pacmanPos, ghosts, black);
        		}

        		// ב. בדיקת רוחות כחולות (אם הן קרובות מאוד)
        		for (GhostCL g : ghosts) {
        			if (g.remainTimeAsEatable(0) > 5) {
        				Ex3P.Index2D gPos = parsePos(g.getPos(0));
        				if (pacmanPos.distance2D(gPos) < 10) {
        					return getMoveTowards(pacmanPos, gPos, black);
        				}
        			}
        		}

        		// ג. חיפוש נקודה ורודה (היעד העיקרי לנצחון)
        		int pink = Game.getIntColor(Color.PINK, code);
        		Ex3P.Index2D pinkTarget = null;

        		if (distFromMe != null) {
        			pinkTarget = findClosestBFS(board, pink, distFromMe);
        		}

        		// גיבוי: אם BFS נכשל, מצא נקודה ורודה לפי מרחק אווירי
        		if (pinkTarget == null) {
        			pinkTarget = findClosestColor(board, pink, pacmanPos);
        		}

        		if (pinkTarget != null) {
        			return getMoveTowards(pacmanPos, pinkTarget, black);
        		}

        		// ד. מהלך ברירת מחדל בטוח - לעולם לא להחזיר סתם UP
        		return getSafeFallbackMove(pacmanPos, black);
        	}

        	private int getMoveTowards(Ex3P.Index2D src, Ex3P.Index2D dest, int black) {
        		Ex3P.Pixel2D[] path = _map.shortestPath(src, dest, black);
        		if (path != null && path.length > 1) {
        			return calculateDirection(src, (Ex3P.Index2D) path[1]);
        		}
        		// אם shortestPath נכשל, ננסה לזוז לכיוון הכללי של היעד
        		return getGeneralDirection(src, dest, black);
        	}

        	private int getGeneralDirection(Ex3P.Index2D src, Ex3P.Index2D dest, int black) {
        		int[] dirs = {Game.UP, Game.DOWN, Game.LEFT, Game.RIGHT};
        		int bestDir = Game.UP;
        		double minDist = Double.MAX_VALUE;

        		for (int d : dirs) {
        			Ex3P.Index2D next = getNext(src, d);
        			if (_map.isInside(next) && _map.getPixel(next) != black) {
        				double dist = next.distance2D(dest);
        				if (dist < minDist) {
        					minDist = dist;
        					bestDir = d;
        				}
        			}
        		}
        		return bestDir;
        	}

        	private int getSafeFallbackMove(Ex3P.Index2D p, int black) {
        		int[] dirs = {Game.UP, Game.DOWN, Game.LEFT, Game.RIGHT};
        		for (int d : dirs) {
        			Ex3P.Index2D next = getNext(p, d);
        			if (_map.isInside(next) && _map.getPixel(next) != black) return d;
        		}
        		return Game.UP;
        	}

        	private int getSmartFleeMove(Ex3P.Index2D p, GhostCL[] ghosts, int black) {
        		int bestDir = -1;
        		double maxDist = -1;
        		int[] dirs = {Game.UP, Game.DOWN, Game.LEFT, Game.RIGHT};

        		for (int dir : dirs) {
        			Ex3P.Index2D next = getNext(p, dir);
        			if (_map.isInside(next) && _map.getPixel(next) != black) {
        				double minDistToAnyGhost = Double.MAX_VALUE;
        				for (GhostCL g : ghosts) {
        					minDistToAnyGhost = Math.min(minDistToAnyGhost, next.distance2D(parsePos(g.getPos(0))));
        				}
        				if (minDistToAnyGhost > maxDist) {
        					maxDist = minDistToAnyGhost;
        					bestDir = dir;
        				}
        			}
        		}
        		return bestDir;
        	}

        	private Ex3P.Index2D findClosestBFS(int[][] board, int color, Ex3P.Map2D distMap) {
        		Ex3P.Index2D best = null;
        		int minD = Integer.MAX_VALUE;
        		for (int x = 0; x < board.length; x++) {
        			for (int y = 0; y < board[0].length; y++) {
        				if (board[x][y] == color) {
        					int d = distMap.getPixel(x, y);
        					if (d != -1 && d < minD) {
        						minD = d;
        						best = new Ex3P.Index2D(x, y);
        					}
        				}
        			}
        		}
        		return best;
        	}


        	private int calculateDirection(Ex3P.Index2D src, Ex3P.Index2D dest) {
        		if (dest.getX() > src.getX()) return Game.RIGHT;
        		if (dest.getX() < src.getX()) return Game.LEFT;
        		if (dest.getY() > src.getY()) return Game.UP;
        		if (dest.getY() < src.getY()) return Game.DOWN;
        		return Game.UP;
        	}

        	private Ex3P.Index2D parsePos(String pos) {
        		String[] p = pos.split(",");
        		return new Ex3P.Index2D(Integer.parseInt(p[0]), Integer.parseInt(p[1]));
        	}

        	private int boardAt(Ex3P.Index2D p, PacmanGame game) {
        		return game.getGame(0)[p.getX()][p.getY()];
        	}

        	private Ex3P.Index2D getNext(Ex3P.Index2D p, int dir) {
        		if (dir == Game.DOWN) return new Ex3P.Index2D(p.getX(), p.getY() + 1);
        		if (dir == Game.UP) return new Ex3P.Index2D(p.getX(), p.getY() - 1);
        		if (dir == Game.LEFT) return new Ex3P.Index2D(p.getX() - 1, p.getY());
        		if (dir == Game.RIGHT) return new Ex3P.Index2D(p.getX() + 1, p.getY());
        		return p;
        	}

        	public int getMoveTowards(Ex3P.Index2D src, Ex3P.Index2D dest) {
        		int black = Game.getIntColor(Color.BLACK, 0);
        		Ex3P.Pixel2D[] path = _map.shortestPath(src, dest, black);
        		if (path != null && path.length > 1) {
        			return calculateDirection(src, new Ex3P.Index2D(path[1]));
        		}
        		return Game.UP;
        	}


        	private GhostCL findClosestGhost(Ex3P.Index2D p, GhostCL[] ghosts) {
        		GhostCL closest = null;
        		double minD = Double.MAX_VALUE;
        		for (GhostCL g : ghosts) {
        			double d = p.distance2D(parsePos(g.getPos(0)));
        			if (d < minD) {
        				minD = d;
        				closest = g;
        			}
        		}
        		return closest;
        	}

        	private Ex3P.Index2D findClosestColor(int[][] board, int color, Ex3P.Index2D pos) {
        		Ex3P.Index2D res = null;
        		double minD = Double.MAX_VALUE;
        		for (int x = 0; x < board.length; x++) {
        			for (int y = 0; y < board[0].length; y++) {
        				if (board[x][y] == color) {
        					double d = pos.distance2D(new Ex3P.Index2D(x, y));
        					if (d < minD) {
        						minD = d;
        						res = new Ex3P.Index2D(x, y);
        					}
        				}
        			}
        		}
        		return res;
        	}


        	private static void printBoard(int[][] b) {
        		for (int y = 0; y < b[0].length; y++) {
        			for (int x = 0; x < b.length; x++) {
        				int v = b[x][y];
        				System.out.print(v + "\t");
        			}
        			System.out.println();
        		}
        	}

        	private static void printGhosts(GhostCL[] gs) {
        		for (int i = 0; i < gs.length; i++) {
        			GhostCL g = gs[i];
        			System.out.println(i + ") status: " + g.getStatus() + ",  type: " + g.getType() + ",  pos: " + g.getPos(0) + ",  time: " + g.remainTimeAsEatable(0));
        		}
        	}

        	private static int randomDir() {
        		int[] dirs = {Game.UP, Game.LEFT, Game.DOWN, Game.RIGHT};
        		int ind = (int) (Math.random() * dirs.length);
        		return dirs[ind];
        	}
}
גרסה 2 -
//package assignments.Ex3;

import exe.ex3.game.Game;
import exe.ex3.game.GhostCL;
import exe.ex3.game.PacManAlgo;
import exe.ex3.game.PacmanGame;

import java.awt.*;
import java.util.Arrays;

/**
 * This is the major algorithmic class for Ex3 - the PacMan game:
 *
 * This code is a very simple example (random-walk algorithm).
 * Your task is to implement (here) your PacMan algorithm.
 */
public class Ex3Algo implements PacManAlgo {
	private int _count;
	private Ex3P.Map2D _map = null;// לא מאתחלים עם null בבנאי
	private int _lastDir = Game.UP;
	private int BLUE, PINK, GREEN, GRAY;
	private static final int DANGER_DIST = 7;
	private static final int GREEN_DIST = 4;
	private static final int HUNT_BUFFER = 3;


	public Ex3Algo() {
		_count = 0;
	}

	@Override
	/**
	 *  Add a short description for the algorithm as a String.
	 */
	public String getInfo() {
		String ans = "this function does the pacman algorithem - level 0 - if there arent any monsters alive and whileexist a pink point do alldistance for the map and do shortestpath" +
				" to the closest pink pointif there is a monster exist - do all distance for her location aad all the" +
				" maps (of all distance for each monster ) if min of the location of all monsters active is les then 7 -for the " +
				"closes  go to one of the neighbors (with get neighbors function) that his distance for the closest monster is the biggestif there is a green  foint in distance of 4 or less and shortest path to her is in places equals or bigger tothe closest monster - go to the green point and if a monster is closest than the time that remains (we can reach to a monster in the left time) go to the monster and eat her ( do not enter to their home anyway)   ";
		return ans;
	}

	@Override
	/**
	 * This ia the main method - that you should design, implement and Ex3P.test.
	 */
	public int move(PacmanGame game) {
		int code = 0;
		int[][] board = game.getGame(code);

		// אתחול צבעים ומפה בסיסית
		if (_map == null) {
			_map = new Ex3P.Map(board);
			BLUE = Game.getIntColor(Color.BLUE, code);
			PINK = Game.getIntColor(Color.PINK, code);
			GREEN = Game.getIntColor(Color.GREEN, code);
		} else { _map.init(board); }

		Ex3P.Index2D me =  parsePos(game.getPos(code));
		GhostCL[] ghosts = game.getGhosts(code);

		// 1. חסימת בית הרוחות - קריטי כדי שלא ייתקע כמו בסרטון
		applyGhostHouseBypass(board);

		// 2. חישוב מפת סכנה *רק* מרוחות פעילות (מסוכנות)
		double[][] dangerMap = buildActiveDangerMap(ghosts);

		// 3. בחירת יעד (רוח אכילה או נקודה ורודה)
		Ex3P.Map2D distFromMe = _map.allDistance(me, BLUE);
		Ex3P.Pixel2D target = selectSmartTarget(board, ghosts, distFromMe);

		// 4. הערכת המהלכים האפשריים
		int bestDir = -1;
		double bestScore = Double.NEGATIVE_INFINITY;

		for (int dir : new int[]{Game.UP, Game.DOWN, Game.LEFT, Game.RIGHT}) {
			Ex3P.Pixel2D next = getNextPos(me, dir);

			// בדיקת חוקיות: לא להיכנס לקירות (BLUE)
			if (!_map.isInside(next) || _map.getPixel(next) == BLUE) continue;

			double score = evaluateSmartMove(next, target, dangerMap, board, dir);

			if (score > bestScore) {
				bestScore = score;
				bestDir = dir;
			}
		}

		_lastDir = (bestDir != -1) ? bestDir : getEmergencyMove(me);
		return _lastDir;
	}
	private Ex3P.Pixel2D selectSmartTarget(int[][] board, GhostCL[] ghosts, Ex3P.Map2D distFromMe) {
		Ex3P.Pixel2D bestGhostTarget = null;
		int minGhostDist = Integer.MAX_VALUE;
		int huntBuffer = 3; // מרווח ביטחון כדי לא להגיע לרוח בדיוק כשהיא הופכת למסוכנת

		// 1. חיפוש רוח אכילה (Edible Ghost) קרובה שאפשר להספיק להגיע אליה
		for (GhostCL g : ghosts) {
			// בדיקה אם הרוח במצב אכיל (זמן > 0)
			double edibleTime = g.remainTimeAsEatable(0);
			if (edibleTime > 0) {
				Ex3P.Index2D gPos = parsePos(g.getPos(0)); // המרת מיקום הרוח
				int distToGhost = distFromMe.getPixel(gPos); // מרחק הליכה אמיתי

				// תנאי הצייד: האם המרחק קטן מהזמן שנותר (פלוס מרווח ביטחון)?
				if (distToGhost != -1 && distToGhost < edibleTime - huntBuffer) {
					if (distToGhost < minGhostDist) {
						minGhostDist = distToGhost;
						bestGhostTarget = gPos;
					}
				}
			}
		}

		// אם נמצאה רוח אכילה מתאימה, היא הופכת ליעד העדיף
		if (bestGhostTarget != null) {
			return bestGhostTarget;
		}

		// 2. אם אין רוח אכילה, חפש את הנקודה הוורודה הקרובה ביותר
		Ex3P.Pixel2D pinkTarget = findClosest(board, PINK, distFromMe);
		if (pinkTarget != null) {
			return pinkTarget;
		}

		// 3. עדיפות אחרונה: נקודה ירוקה (Power Pill)
		return findClosest(board, GREEN, distFromMe);
	}
	private double[][] buildActiveDangerMap(GhostCL[] ghosts) {
		int w = _map.getWidth(), h = _map.getHeight();
		double[][] danger = new double[w][h];
		for (double[] row : danger) Arrays.fill(row, 99.0); // 99 = בטוח לחלוטין

		for (GhostCL g : ghosts) {
			// התנאי שביקשת: אם הרוח אכילה (זמן > 0), היא לא נחשבת מסוכנת
			if (g.remainTimeAsEatable(0) > 1.0) continue;

			Ex3P.Pixel2D gPos =  parsePos(g.getPos(0));
			Ex3P.Map2D gDist = _map.allDistance(gPos, BLUE); // מרחק הליכה אמיתי מהרוח
			if (gDist == null) continue;

			for (int x = 0; x < w; x++) {
				for (int y = 0; y < h; y++) {
					int d = gDist.getPixel(x, y);
					if (d != -1) danger[x][y] = Math.min(danger[x][y], d);
				}
			}
		}
		return danger;
	}

	/**
	 * פונקציית הערכה שמתעדפת מרחק מרוחות פעילות בלבד.
	 */
	private double evaluateSmartMove(Ex3P.Pixel2D pos, Ex3P.Pixel2D target, double[][] danger, int[][] board, int dir) {
		double score = 0;
		int x = pos.getX(), y = pos.getY();

		// 1. עונש מוות: להתרחק מרוחות פעילות (טווח 2-3 הוא קריטי)
		double ghostDist = danger[x][y];
		if (ghostDist <= 1.1) return -1000000.0; // התאבדות
		if (ghostDist <= 3.0) score -= 100000.0 / (ghostDist + 0.1);

		// 2. בונוס יעד: להתקדם ליעד (אוכל או רוח כחולה)
		if (target != null) {
			double dToTarget = pos.distance2D(target);
			score += 5000.0 / (dToTarget + 1);
		}

		// 3. עקביות: בונוס על המשך כיוון תנועה
		if (dir == _lastDir) score += 200;

		return score;
	}

	/**
	 * חוסם את אזור המלבן המרכזי כדי למנוע מהפקמן להיכנס למלכודת.
	 */
	private void applyGhostHouseBypass(int[][] board) {
		int midX = board.length / 2;
		int midY = board[0].length / 2;
		// חסימת האזור המרכזי (בית הרוחות)
		for (int x = midX - 3; x <= midX + 3; x++) {
			for (int y = midY - 2; y <= midY + 2; y++) {
				if (_map.isInside(new Ex3P.Index2D(x, y))) {
					_map.setPixel(x, y, BLUE);
				}
			}
		}
	}



	/**
	 * יצירת מפה שמציינת את המרחק של כל משבצת מהרוח הקרובה ביותר.
	 */
	private double[][] buildDangerMap(GhostCL[] ghosts) {
		int w = _map.getWidth(), h = _map.getHeight();
		double[][] danger = new double[w][h];
		for (double[] row : danger) Arrays.fill(row, 99.0);

		for (GhostCL g : ghosts) {
			if (g.remainTimeAsEatable(0) > 2.0) continue; // רוח כחולה אינה מסוכנת

			Ex3P.Pixel2D gPos =  parsePos(g.getPos(0));
			Ex3P.Map2D gDist = _map.allDistance(gPos, BLUE);
			if (gDist == null) continue;

			for (int x = 0; x < w; x++) {
				for (int y = 0; y < h; y++) {
					int d = gDist.getPixel(x, y);
					if (d != -1) danger[x][y] = Math.min(danger[x][y], d);
				}
			}
		}
		return danger;
	}

	private Ex3P.Pixel2D getNextPos(Ex3P.Pixel2D p, int dir) {
		int x = p.getX(), y = p.getY();
		if (dir == Game.UP) y++;
		else if (dir == Game.DOWN) y--;
		else if (dir == Game.LEFT) x--;
		else if (dir == Game.RIGHT) x++;

		// תמיכה בלוח מחזורי (Cyclic)
		int w = _map.getWidth(), h = _map.getHeight();
		return new Ex3P.Index2D((x + w) % w, (y + h) % h);
	}

	private Ex3P.Pixel2D findClosest(int[][] board, int color, Ex3P.Map2D distMap) {
		Ex3P.Pixel2D best = null;
		int minD = Integer.MAX_VALUE;
		for (int x = 0; x < board.length; x++) {
			for (int y = 0; y < board[0].length; y++) {
				if (board[x][y] == color) {
					int d = distMap.getPixel(x, y);
					if (d != -1 && d < minD) {
						minD = d;
						best = new Ex3P.Index2D(x, y);
					}
				}
			}
		}
		return best;
	}

	private int getEmergencyMove(Ex3P.Pixel2D me) {
		int[] dirs = {Game.UP, Game.DOWN, Game.LEFT, Game.RIGHT};
		for (int d : dirs) {
			Ex3P.Pixel2D n = getNextPos(me, d);
			if (_map.isInside(n) && _map.getPixel(n) != BLUE) return d;
		}
		return Game.UP;
	}

	/**
	 * בוחר יעד לפי סדר עדיפויות:
	 * 1. רוח כחולה (אם אפשר להספיק)
	 * 2. נקודה ורודה קרובה
	 */
	private Ex3P.Pixel2D selectBestTarget(int[][] board, GhostCL[] ghosts, Ex3P.Map2D distFromMe) {
		Ex3P.Pixel2D bestGhost = null;
		int minDist = Integer.MAX_VALUE;

		for (GhostCL g : ghosts) {
			double remainTime = g.remainTimeAsEatable(0);
			if (remainTime > 0) {
				Ex3P.Pixel2D gPos = parsePos(g.getPos(0));
				int d = distFromMe.getPixel(gPos);

				// תנאי הצייד: רק אם המרחק קטן מהזמן שנותר פלוס באפר
				if (d != -1 && d < remainTime - HUNT_BUFFER) {
					if (d < minDist) {
						minDist = d;
						bestGhost = gPos;
					}
				}
			}
		}

		// אם יש רוח שאפשר לאכול, היא הופכת ליעד העליון
		if (bestGhost != null) return bestGhost;

		// אחרת, חזור ליעד הרגיל - נקודה ורודה קרובה [cite: 2]
		return findClosest(board, PINK, distFromMe);
	}
	private Ex3P.Index2D parsePos(String pos) {
		String[] p = pos.split(",");
		return new Ex3P.Index2D(Integer.parseInt(p[0]), Integer.parseInt(p[1]));
	}

	private double evaluateMove(Ex3P.Pixel2D pos, Ex3P.Pixel2D target, double[][] danger, int[][] board, int dir) {
		double score = 0;
		int x = pos.getX(), y = pos.getY();

		// עונש סכנה - מונע התאבדות מול רוחות רגילות
		double dng = danger[x][y];
		if (dng <= 1.5) return -1000000;
		score += dng * 150;

		// בונוס יעד - אם היעד הוא רוח, הבונוס יהיה גבוה יותר
		if (target != null) {
			double distToTarget = pos.distance2D(target);
			score += (5000.0 / (distToTarget + 1));
		}

		if (dir == _lastDir) score += 100; // מניעת רעידות
		return score;
	}
}
גרסה 3 -
int code = 0;
		int[][] board = game.getGame(code);

		// יצירת מפה נקייה בכל צעד כדי למנוע באגים של "לכלוך" המפה
		Ex3P.Map map = new Ex3P.Map(board);
		map.setCyclic(true); // עקרון מהדוגמה השנייה: תמיכה במחזוריות

		BLUE = Game.getIntColor(Color.BLUE, code);
		PINK = Game.getIntColor(Color.PINK, code);
		GREEN = Game.getIntColor(Color.GREEN, code);

		Ex3P.Pixel2D me = parsePos(game.getPos(code));
		GhostCL[] ghosts = game.getGhosts(code);

		// 1. הגדרת גבולות בית הרוחות (7x4 במרכז)
		int midX = board.length / 2;
		int midY = board[0].length / 2;
		Ex3P.Pixel2D houseP1 = new Ex3P.Index2D(midX - 3, midY - 2);
		Ex3P.Pixel2D houseP2 = new Ex3P.Index2D(midX + 3, midY + 1);

		// 2. חישוב מרחקים נקי (עקרון מהדוגמה הראשונה: תמיד עובד כי המפה לא חסומה)
		Ex3P.Map2D distFromMe = map.allDistance(me, BLUE);

		// 3. בניית מפת סכנה (רק מרוחות פעילות ומחוץ לבית)
		double[][] dangerMap = buildDangerMap(map, board, ghosts, houseP1, houseP2);

		// 4. לולאת קבלת החלטות (עקרון מהדוגמה השנייה: בדיקת כל הכיוונים)
		int bestDir = -1;
		double bestScore = Double.NEGATIVE_INFINITY;

		for (int dir : new int[]{Game.UP, Game.DOWN, Game.LEFT, Game.RIGHT}) {
			Ex3P.Pixel2D next = neighbor(me, dir, map); // שימוש בפונקציית neighbor מחזורית

			// --- בדיקות חוקיות (החלק הקריטי למניעת תקיעה) ---

			// א. האם זה קיר?
			if (!map.isInside(next) || board[next.getX()][next.getY()] == BLUE) continue;

			// ב. חסימת בית הרוחות (לוגית בלבד!)
			// נכנסים רק אם אנחנו כבר בטעות בפנים וצריכים לצאת
			if (isInsideRect(next, houseP1, houseP2) && !isInsideRect(me, houseP1, houseP2)) {
				continue; // מדלגים על המהלך הזה - הוא מוביל לבית הרוחות
			}

			// ג. חישוב ניקוד
			double score = evaluate(next, board, distFromMe, dangerMap, dir);

			if (score > bestScore) {
				bestScore = score;
				bestDir = dir;
			}
		}

		// 5. מנגנון אל-כשל (עקרון מהדוגמה הראשונה: validMove)
		// אם הכל נכשל, פשוט זוז לכל משבצת פנויה כדי לא לקפוא
		if (bestDir == -1) {
			return getAnyValidMove(me, map, board);
		}

		_lastDir = bestDir;
		return bestDir;
	}

	/**
	 * פונקציית הניקוד (שילוב של הדוגמאות):
	 * - בריחה רק אם המרחק < 7.
	 * - עדיפות לאוכל.
	 * - בונוס יציבות.
	 */
	private double evaluate(Ex3P.Pixel2D pos, int[][] board, Ex3P.Map2D dists, double[][] danger, int dir) {
		double score = 0;
		int x = pos.getX(), y = pos.getY();

		// סכנה: בריחה רק אם הרוח קרובה מ-7 צעדים
		double dng = danger[x][y];
		if (dng <= 1.1) return -10000000; // מוות ודאי
		if (dng <= DANGER_RADIUS) {
			// ככל שמתקרבים ל-0, העונש גדל משמעותית
			score -= (DANGER_RADIUS - dng) * 100000;
		}

		// אוכל: התקרבות לנקודה ורודה (באמצעות BFS מהדוגמה השנייה)
		if (dists != null) {
			Ex3P.Pixel2D target = findClosest(board, PINK, dists);
			if (target != null) {
				// אומדן מרחק ליעד
				double d = pos.distance2D(target);
				score += 5000.0 / (d + 1);
			}
		}

		// בונוסים מקומיים
		if (board[x][y] == PINK) score += 2000;
		if (board[x][y] == GREEN) score += 500;
		if (dir == _lastDir) score += 50; // מניעת רעידות

		return score;
	}

	/**
	 * בונה מפת סכנה. מתעלמת מרוחות בתוך הבית (כדי לעבור ליד הקירות בבטחה).
	 */
	private double[][] buildDangerMap(Ex3P.Map map, int[][] board, GhostCL[] ghosts, Ex3P.Pixel2D p1, Ex3P.Pixel2D p2) {
		int w = board.length, h = board[0].length;
		double[][] dMap = new double[w][h];
		for (double[] r : dMap) java.util.Arrays.fill(r, 99.0);

		for (GhostCL g : ghosts) {
			Ex3P.Pixel2D gp = parsePos(g.getPos(0));

			// סינון רוחות (עקרון מהדוגמה הראשונה):
			// 1. אם הרוח אכילה - לא בורחים.
			// 2. אם הרוח בתוך הבית - לא בורחים (היא כלואה).
			if (g.remainTimeAsEatable(0) > 1.0 || isInsideRect(gp, p1, p2)) continue;

			// חישוב מרחק BFS אמיתי (דרך הקירות הפתוחים)
			Ex3P.Map2D gDist = map.allDistance(gp, BLUE);
			if (gDist == null) continue;

			for (int x = 0; x < w; x++) {
				for (int y = 0; y < h; y++) {
					int d = gDist.getPixel(x, y);
					if (d != -1) {
						dMap[x][y] = Math.min(dMap[x][y], d);
					}
				}
			}
		}
		return dMap;
	}

	// --- פונקציות עזר מהדוגמאות ---

	private int getAnyValidMove(Ex3P.Pixel2D me, Ex3P.Map map, int[][] board) {
		for (int d : new int[]{Game.UP, Game.RIGHT, Game.DOWN, Game.LEFT}) {
			Ex3P.Pixel2D n = neighbor(me, d, map);
			if (map.isInside(n) && board[n.getX()][n.getY()] != BLUE) return d;
		}
		return Game.UP;
	}

	private boolean isInsideRect(Ex3P.Pixel2D p, Ex3P.Pixel2D p1, Ex3P.Pixel2D p2) {
		int minX = Math.min(p1.getX(), p2.getX());
		int maxX = Math.max(p1.getX(), p2.getX());
		int minY = Math.min(p1.getY(), p2.getY());
		int maxY = Math.max(p1.getY(), p2.getY());
		return p.getX() >= minX && p.getX() <= maxX && p.getY() >= minY && p.getY() <= maxY;
	}

	private Ex3P.Pixel2D neighbor(Ex3P.Pixel2D p, int dir, Ex3P.Map map) {
		int x = p.getX(), y = p.getY();
		if (dir == Game.UP) y++; else if (dir == Game.DOWN) y--;
		else if (dir == Game.LEFT) x--; else if (dir == Game.RIGHT) x++;
		int w = map.getWidth(), h = map.getHeight();
		return new Ex3P.Index2D((x + w) % w, (y + h) % h); // מחזוריות
	}

	private Ex3P.Pixel2D findClosest(int[][] board, int color, Ex3P.Map2D distMap) {
		if (distMap == null) return null;
		Ex3P.Pixel2D best = null; int minD = Integer.MAX_VALUE;
		for (int x = 0; x < board.length; x++) {
			for (int y = 0; y < board[0].length; y++) {
				if (board[x][y] == color) {
					int d = distMap.getPixel(x, y);
					if (d != -1 && d < minD) { minD = d; best = new Ex3P.Index2D(x, y); }
				}
			}
		}
		return best;
	}

	private Ex3P.Index2D parsePos(String pos) {
		String[] p = pos.split(",");
		return new Ex3P.Index2D(Integer.parseInt(p[0]), Integer.parseInt(p[1]));
	}
}
גרסה עובדת -
//package assignments.Ex3;
package Ex3P;
import exe.ex3.game.Game;
import exe.ex3.game.GhostCL;
import exe.ex3.game.PacManAlgo;
import exe.ex3.game.PacmanGame;


import java.awt.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;


import java.util.Queue;

/**
 * This is the major algorithmic class for Ex3 - the PacMan game:
 *
 * This code is a very simple example (random-walk algorithm).
 * Your task is to implement (here) your PacMan algorithm.
 */
public class Ex3Algo implements PacManAlgo {
	private int _count;
	private Map2D _map ;// לא מאתחלים עם null בבנאי
	private int _lastDir = Game.UP;
	private int BLUE, PINK, GREEN, GRAY;
	private static final int DANGER_RADIUS = 7;
	private static final int GREEN_DIST = 4;
	private static final int HUNT_BUFFER = 3;


	public Ex3Algo() {
		_count = 0;
	}

	@Override
	/**
	 *  Add a short description for the algorithm as a String.
	 */
	public String getInfo() {
		String ans = "this function does the pacman algorithem - level 0 - if there arent any monsters alive and whileexist a pink point do alldistance for the map and do shortestpath" +
				" to the closest pink pointif there is a monster exist - do all distance for her location aad all the" +
				" maps (of all distance for each monster ) if min of the location of all monsters active is les then 7 -for the " +
				"closes  go to one of the neighbors (with get neighbors function) that his distance for the closest monster is the biggestif there is a green  foint in distance of 4 or less and shortest path to her is in places equals or bigger tothe closest monster - go to the green point and if a monster is closest than the time that remains (we can reach to a monster in the left time) go to the monster and eat her ( do not enter to their home anyway)   ";
		return ans;
	}

	@Override
	/**
	 * This ia the main method - that you should design, implement and Ex3P.test.
	 */
	public int move(PacmanGame game) {
		int pac = 0;
		int[][] board = game.getGame(pac);
		if (_map == null) {
			_map = new Map(board);
		} else {
			_map.init(board);
		}
		_map.setCyclic(GameInfo.CYCLIC_MODE);
		Pixel2D me = parsePos(game.getPos(pac));

		if (_count == 0) {
			BLUE  = Game.getIntColor(Color.BLUE, 0);
			PINK  = Game.getIntColor(Color.PINK, 0);
			GREEN = Game.getIntColor(Color.GREEN, 0);
		}

		GhostCL[] ghosts = game.getGhosts(pac);
		double[][] danger = buildDangerMap((Map) _map, board, ghosts);

		int bestDir = -1;
		double bestScore = Double.NEGATIVE_INFINITY;

		// לולאה אחת מאוחדת - קריטי למניעת "קיפאון"
		for (int dir : new int[]{Game.UP, Game.DOWN, Game.LEFT, Game.RIGHT}) {
			Pixel2D next = neighbor(me, dir, (Map) _map);
			if (!isLegal(next, board)) continue;

			double score = evaluate(next, (Map) _map, board, danger);

			// חישוב עומק - עוזר להחליט בין נתיבים
			Map2D d2 = _map.allDistance(next, BLUE);
			score += 0.5 * futureScore(d2, board, danger);

			// בונוס התמדה חזק יותר - מונע רעידות מול רוח
			if (dir == _lastDir) score += 500;

			if (score > bestScore) {
				bestScore = score;
				bestDir = dir;
			}
		}

		if (bestDir == -1) { // מוצא אחרון אם הכל מסוכן
			for (int d=0; d<4; d++) if (isLegal(neighbor(me, d, (Map) _map), board)) return d;
		}

		_lastDir = bestDir;
		_count++;
		return bestDir;
	}
	private Index2D parsePos(String pos) {
		String[] p = pos.split(",");
		return new Index2D(Integer.parseInt(p[0]), Integer.parseInt(p[1]));
	}
	public double[][] buildDangerMap(Map map, int[][] board, GhostCL[] ghosts) {
		int w = board.length, h = board[0].length;
		double[][] danger = new double[w][h];
		for (double[] r : danger) Arrays.fill(r, 99.0);

		if (ghosts != null && ghosts.length > 0) {
			for (int i = 0; i < ghosts.length; i++) {
				if (ghosts[i].remainTimeAsEatable(i) > 3.0) continue;
				Pixel2D gp = parsePos(ghosts[i].getPos(i));
				Map2D dist = _map.allDistance(gp, BLUE);
				for (int x = 0; x < w; x++) {
					for (int y = 0; y < h; y++) {
						double d = dist.getPixel(x, y);
						if (d != -1) danger[x][y] = Math.min(danger[x][y], d);
					}
				}
			}
		} else {
			// אין רוחות → בנה סכנה לפי צבעים בלוח בלבד
			for (int x = 0; x < w; x++) {
				for (int y = 0; y < h; y++) {
					if (board[x][y] < 0) { // PINK/BLUE/GREEN
						danger[x][y] = 0;
					}
				}
			}
		}

		return danger;
	}
	public double evaluate(Pixel2D pos, Map map, int[][] board, double[][] danger) {
		double score = 0;
		int x = pos.getX(), y = pos.getY();
		double ghostDist = danger[x][y];

		// 1. הגנה אגרסיבית - בורח כבר ממרחק 2-3
		if (ghostDist <= 1.1) return -10000000.0;
		if (ghostDist <= 2.1) score -= 500000.0;
		if (ghostDist <= 3.1) score -= 100000.0;

		// 2. שטח בטוח - מונע כניסה למלכודות
		int safeSpace = countSafeSpace(pos, map, board, danger, 15);
		score += safeSpace * 2000;

		// 3. חיפוש אוכל - עם עדיפות חזקה לקרוב
		Map2D distMap = _map.allDistance(pos, BLUE);
		Pixel2D pink = closest(board, distMap, PINK);

		if (pink != null) {
			double d = distMap.getPixel(pink.getX(), pink.getY());
			score += 200000.0 / (d + 1); // הגדלת המשקל של האוכל
		} else {
			score += ghostDist * 5000; // אם אין אוכל, פשוט תתרחק מהרוח
		}

		if (board[x][y] == PINK) score += 10000;

		return score;
	}
	public <Queue> int countSafeSpace(Pixel2D start, Map map, int[][] board, double[][] danger, int limit) {
		 java.util.Queue<Pixel2D> q = new java.util.LinkedList<>();;
		java.util.Map<String, Integer> dist = new HashMap<>();
		q.add(start);
		dist.put(key(start), 0);
		int count = 0;
		while (!q.isEmpty() && count < limit) {
			Pixel2D cur = q.poll();
			int d = dist.get(key(cur));
			count++;
			for (int dir : new int[]{0,1,2,3}) {
				Pixel2D n = neighbor(cur, dir, map);
				if (!isLegal(n, board) || dist.containsKey(key(n))) continue;
				// משבצת נחשבת בטוחה רק אם הרוח לא יכולה להגיע אליה לפנינו (או איתנו)
				if (danger[n.getX()][n.getY()] <= d + 1) continue;
				dist.put(key(n), d + 1);
				q.add(n);
			}
		}
		return count;
	}
	public double futureScore(Map2D dist, int[][] board, double[][] danger) {
		double best = 0;
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				if (board[i][j] == PINK) {
					double d = dist.getPixel(i, j);
					if (d != -1 && danger[i][j] > d + 2) {
						best = Math.max(best, 100000 / (d + 1));
					}
				}
			}
		}
		return best;
	}
	public Pixel2D closest(int[][] board, Map2D dist, int color) {
		Pixel2D best = null; double min = Double.MAX_VALUE;
		for (int i = 0; i < board.length; i++)
			for (int j = 0; j < board[0].length; j++)
				if (board[i][j] == color && dist.getPixel(i, j) != -1 && dist.getPixel(i, j) < min) {
					min = dist.getPixel(i, j); best = new Index2D(i, j);
				}
		return best;
	}
	public Pixel2D neighbor(Pixel2D p, int dir, Map map) {
		int x = p.getX(), y = p.getY();
		if (dir == Game.UP) y++; else if (dir == Game.DOWN) y--;
		else if (dir == Game.LEFT) x--; else if (dir == Game.RIGHT) x++;
		int w = _map.getMap().length, h = _map.getMap()[0].length;
		return new Index2D((x + w) % w, (y + h) % h);
	}
	public boolean isLegal(Pixel2D p, int[][] board) {
		if (p.getX() < 0 || p.getX() >= board.length || p.getY() < 0 || p.getY() >= board[0].length) return false;
		return board[p.getX()][p.getY()] != BLUE && !isGhostHouse(p, board);
	}
	public boolean isGhostHouse(Pixel2D p, int[][] board) {
		int mx = board.length / 2, my = board[0].length / 2;
		return Math.abs(p.getX() - mx) < 3 && Math.abs(p.getY() - my) < 3 && board[p.getX()][p.getY()] == 0;
	}
	public String key(Pixel2D p) { return p.getX() + "," + p.getY(); }
}
